/*
========================================================================================
    Nextflow config file for running full-size tests
========================================================================================
    Defines input files and everything required to run a full size pipeline test.

    Use as follows:
        nextflow run nf-core/eqtl -profile test_full,<docker/singularity>

----------------------------------------------------------------------------------------
*/

params {

    method= 'single_cell' //or a [bulk | single_cell] (if single cell used the *phenotype_file* is a h5ad file)
    input_vcf ='https://yascp.cog.sanger.ac.uk/public/test_datasets/full_test_dataset/smaller_dataset/genotypes/coding_chr_Pool1_INFO_0.9_MAF_0.001.vcf.gz'
    genotype_phenotype_mapping_file = 'https://yascp.cog.sanger.ac.uk/public/test_datasets/QTLight/gt_mapping_test.tsv' // annotation file containing Genotype | RNA and | Condiion
    annotation_file = 'https://yascp.cog.sanger.ac.uk/public/test_datasets/QTLight/Homo_sapiens.GRCh38.99.gtf' //assets file that has start and end positions for the genes, this one is using hg38
    phenotype_file = 'https://yascp.cog.sanger.ac.uk/public/test_datasets/QTLight/test_Onek1kPool1.h5ad' //this should point to h5ad file in a single cell experiments, ensuring adata.X is raw counts
    aggregation_columns='Azimuth:predicted.celltype.l1' //for the scrna h5ad file define which annotations to use when aggregating the data. Can be one value or multiple comma separated values

    gt_id_column = 'Pool.Donor'
    // Column in the AnnData `.obs` that contains the **donor-level identifier**.
    // This value should match the **genotype ID** in your VCF/PLINK file (e.g. in `.psam`, `.fam`, or `.vcf`),
    // or — if you're using a genotype–phenotype mapping (bridging) file — it should match the `RNA` column in that file.
    // Used to map aggregated expression values to the correct genotype during QTL analysis.

    sample_column = 'Pool.Donor'
    // Column in the AnnData `.obs` that contains the **sample-level identifier**,
    // representing a single RNA-seq measurement (e.g., one library or sequencing reaction).
    // Used to distinguish multiple samples or runs from the same donor.
    // Can be identical to `gt_id_column` if each sample uniquely maps to one genotype.
    // Combined with `gt_id_column` to generate unique donor-sample IDs for expression aggregation.

    n_min_individ = '3'
    split_aggregation_adata=true
    windowSize=250000
    aggregation_subentry='Mono'
    analysis_subentry='Mono'
    chromosomes_to_test=[18,1] // Which chromosomes to test?
    
    LIMIX{
        run=true // Are we running limix? 
        callRate=0.95 // what call rate to use? 
        blockSize=1500 // What block size to use for mapping?
        hwe=0.0000001 // What hwe to use? 
        numberOfPermutations=10 // how many permutations to use?
        
    }

    covariates{
        nr_phenotype_pcs = '2,4' // this is used for Tensorqtl and Limix
        nr_genotype_pcs = 4 // How many genotype PCs to use
        genotype_pc_filters = '--indep-pairwise 50 5 0.2 --bad-ld'
        extra_covariates_file = '' // if there is any extra covariates that you would like to use, provide it here. It should be a tsv file that contains genotype_id and covariates as such:
        // sample   682_683  683_684  684_685  685_686  686_687  687_688  688_689  689_690  690_691  691_692  692_693  693_694
        // cov1          1        2        0        2        2        3        2        1        0        0        0        1
        genotype_pcs_file = '' //if you have already precalculated genotype PCs you can provide it in here. Make sure that the number of genotype PCs above is covered (for exaple that there are at least 4 PCs represented since we defined that GPcs to use == 4)
        adata_obs_covariate =''
    }

    JAXQTL{
        run=true // Are we running JaxQTL?
        number_of_genes_per_chunk = 50 // How many genes to run at a time for the JaxQTL chunk.
        use_gpu = false // should we use cpus or GPU for the jobs?
    }

    QUASAR{
        run=true // Are we running Quasar?
        mode='cis' // mode is a choice of cis, trans and gwas, only cis works with quasar at present
        model='lm' // model may be lm, lmm, p_glm, p_glmm, nb_glm. 
    }

    SAIGE{
        run=tru // Are we running saige? 
        nr_expression_pcs=5 // How many scRNA expression PCs to use?
        q_val_threshold_for_conditioning=0.05 // If there are >1 genes with q < this, send for conditioning rounds
        minMAF=0.05 // Minimum minor allele frequency to include SNPs
        minMAC=20 // Minimum minor allele count to include SNPs
        SPAcutoff=2 // Cutoff for SPA test (step 2); higher skips fewer SNPs
        markers_per_chunk=10000 // How many markers to test per chunk
        covariate_obs_columns='' // AnnData .obs columns to use as covariates
        cis_trans_mode='cis' // Mode to run: 'cis' or 'trans' associations
        trans_chr_to_test='SAME' // For trans-QTLs, test SAME chromosome as gene or specify one (e.g. '20')

        relatednessCutoff=0.005 // Minimum kinship coefficient for sparse GRM (0.05 ~ 2nd degree relatives)
        numRandomMarkerforSparseKin=1000 // Number of markers to compute sparse GRM

        useSparseGRMtoFitNULL='TRUE' // Use sparse GRM for null model fitting (step 1)
        useSparseGRMforVarRatio='FALSE' // Use sparse GRM to estimate variance ratio (step 1)
        isCateVarianceRatio='TRUE' // Estimate variance ratio per MAC category
        cateVarRatioMinMACVecExclude='0,5' // Lower MAC bin edges to exclude
        cateVarRatioMaxMACVecInclude='4,8' // Upper MAC bin edges to include
        numRandomMarkerforVarianceRatio=1000 // Number of markers to estimate variance ratio

        skipModelFitting='FALSE' // Skip null model fitting if .rda already exists
        skipVarianceRatioEstimation='FALSE' // Skip variance ratio estimation if file already exists

        isCovariateTransform='FALSE' // QR-transform covariates (default TRUE in some setups)
        isCovariateOffset='FALSE' // Include offset term for fixed effect estimation
        isRemoveZerosinPheno='TRUE' // Remove 0s from phenotype values before fitting

        tol=0.000001 // Tolerance for null model convergence
        traceCVcutoff=0.0005 // Coefficient of variation threshold for trace estimator
        nrun=105 // Number of runs for trace estimation
  
        step1_extra_flags='' // Extra flags to inject into step1 (fitNULLGLMM)
        useGRMtoFitNULL='FALSE'
        minMAFforGRM='0.0001'
        maxMissingRateforGRM='0.8'
        maxiterPCG=5000
        invNormalize = 'FALSE'
        LOCO='FALSE'
    }

}

process{
    withName: PHENOTYPE_PCs{
        cpus  = 1 
        time   = { 12.h   * task.attempt    } 
         memory = { 1.GB * task.attempt }
    }
    withName: SAIGE_S1{
        time   = { 12.h   * task.attempt    }
        maxRetries    = 3
        maxForks = 6
        memory = { 12.GB * task.attempt }
    }

    withName: LIMIX{
        time   = { 12.h   * task.attempt    }
        maxRetries    = 3
        maxForks = 8
        memory = { 12.GB * task.attempt }
    }
    
    withName: DETERMINE_TSS_AND_TEST_REGIONS{
        time   = { 12.h   * task.attempt    }
        maxRetries    = 3
        maxForks = 3
        memory = { 15.GB * task.attempt }
    }
    withName: SAIGE_S2_CIS{
        time   = { 12.h   * task.attempt    }
        maxRetries    = 3
        maxForks = 3
        memory = { 4.GB * task.attempt }
    }
    
    withName: SPLIT_AGGREGATION_ADATA{
        time   = { 12.h   * task.attempt    }
        maxRetries    = 3
        memory = { 12.GB * task.attempt }
    }    

}